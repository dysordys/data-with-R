# Basic data manipulation {#sec-wrangling}

## Selecting and manipulating data

Let us start by loading `tidyverse`, in case you have not done so yet:

```{r}
library(tidyverse)
```

As you can see from the message output above, the `dplyr` package is part of `tidyverse`, which gets loaded by default. It allows one to arrange and manipulate data efficiently. The basic functions one should know are `rename`, `select`, `filter`, `slice`, `arrange`, and `mutate`. The first of these we have already looked at in @sec-rename. Let us then see some examples of the latter ones. First, we will load the `Goldberg2010_data.csv` data file (also discussed in the previous chapter):

```{r}
#| message: false
dat <- read_csv("Goldberg2010_data.csv")
print(dat)
```

Now we will give examples of each of the functions `select`, `filter`, `slice`, `arrange`, and `mutate`. They are similar to our earlier `rename` in that the first argument they take is the data, in the form of a tibble. Their other arguments, and what they each do, are explained below.

### `select`

This function chooses *columns* of the data. The second and subsequent arguments of the function are the columns which should be retained. For example, `select(dat, Species)` will keep only the `Species` column of `dat`:

```{r}
select(dat, Species)
```

It is also possible to deselect columns, by prepending a minus sign (`-`) in front of the column names. To drop the `Species` column, we can type:

```{r}
select(dat, -Species)
```

Since there were only two columns in the data to begin with, only the `Status` column remained in the data after removing `Species`.

### `filter`

While `select` chooses columns, `filter` chooses rows from the data. As with all these functions, the first argument of `filter` is the data. The second argument is a logical condition on the columns. Those rows which satisfy the condition are retained; the rest are dropped. Thus, `filter` keeps only those rows of the data which fulfill some condition.

Recall that in the `Goldberg2010_data.csv` dataset, a `Status` of 0 means self-incompatibility; a `Status` of 1 means self-compatibility, and `Status` values between 2 and 5 refer to various, more complex selfing mechanisms. So in case we wanted to focus only on those species which exhibit complex selfing, we could `filter` the data like this:

```{r}
filter(dat, Status >= 2)
```

### `slice`

With `slice`, one can choose rows of the data, just like with `filter`. Unlike with `filter` however, `slice` receives a vector of row indices instead of a condition to be tested on each row. So, for example, if one wanted to keep only the first, second, and fifth rows, then one can do so with `slice`:

```{r}
slice(dat, c(1, 2, 5))
```

(Note: the numbers in front of the rows in the output generated by tibbles always pertain to the row numbers of the *current table*, not the one from which they were created. So the row labels `1`, `2`, and `3` above simply enumerate the rows of the sliced data. The actual rows still correspond to rows 1, 2, and 5 in the original `dat`.)

### `arrange`

This function rearranges the rows of the data, in increasing order of the column given as the second argument. For example, to arrange in increasing order of `Status`, we write:

```{r}
arrange(dat, Status)
```

To arrange in decreasing order, apply the `desc` function to `Status` within `arrange`, like this:

```{r}
arrange(dat, desc(Status))
```

It is also perfectly possible to arrange by a column whose type is character string. In that case, the system will automagically sort the rows in alphabetical order---or reverse alphabetical order, in case `desc` is applied. For example, to sort in reverse alphabetical order of species binomials:

```{r}
arrange(dat, desc(Species))
```

Notice that when we sorted the rows by `Status`, there are many ties---rows with the same value of `Status`. In those cases, `arrange` will not be able to decide which rows should come earlier, and so any ordering that was present before invoking `arrange` will be retained. In case we would like to break the ties, we can give further sorting variables, as the third, fourth, etc. arguments to `arrange`. To sort the data by `Status`, and to resolve ties in alphabetical order of `Species`, we write:

```{r}
arrange(dat, Status, Species)
```

This causes the table to be sorted primarily by `Status`, but in case there are ties (equal `Status` between multiple rows), they will be resolved in priority of alphabetical order---first those starting with "A" (if they exist), then "B", and so on.

### `mutate`

The `mutate` function allows us to create new columns from existing ones. We may apply any function or operator we learned about to existing columns, and the result of the computation will go into the new column. We do this in the second argument of `mutate` (the first, as always, is the data), by first giving a name to the column, then writing `=`, and then the desired computation. For example, we may find it strange that the selfing status of the species is encoded with a number ranging from 0 to 5, instead of 1 to 6. This is easy to fix however, using `mutate`:

```{r}
mutate(dat, NewStatus = Status + 1)
```

The original columns of the data are retained, but we now also have the additional `NewStatus` column.

Perhaps more interestingly, we could create a new column indicating whether the selfing mechanism of the species is simple (`Status` either 0 or 1) or complex (`Status` between 2 and 5). We can do this using an `ifelse` function within `mutate`:

```{r}
mutate(dat, SelfingMechanism = ifelse(Status < 2, "simple", "complex"))
```


## Using pipes to our advantage

When composing multiple `tidyverse` functions together, things can get unwieldy quite quickly. Let us take the same data, and create the new column `SelfingMechanism` as above. What happens if we then filter for only those entries with complex selfing mechanism, and finally, we select the column `Species` only? Here is the solution:

```{r}
select(
  filter(
    mutate(dat, SelfingMechanism = ifelse(Status < 2, "simple", "complex")),
    SelfingMechanism == "complex"
  ),
  Species
)
```

The expression is highly unpleasant: to a human reader, it is not at all obvious what is happening above. To clarify, we have two options. One is to rely on repeated assignment:

```{r}
mutatedDat <- mutate(dat, SelfingMechanism = ifelse(Status < 2, "simple", "complex"))
filteredDat <- filter(mutatedDat, SelfingMechanism == "complex")
onlySpeciesDat <- select(filteredDat, Species)
print(onlySpeciesDat)
```

This, however, requires inventing arbitrary variable names at every step, or else overwriting variables. For such a short example, this is not problematic, but doing the same for a long pipeline of dozens of steps could get confusing, as well as dangerous due to the repeatedly modified variables.

It turns out that one can get the best of both worlds: the safety of function composition with the conceptual clarity of repeated assignments. This only requires that we make use of the pipe operator `%>%` that we learned about earlier. As a reminder, for any function `f` and function argument `x`, `f(x, y, ...)` is the same as `x %>% f(y, ...)`, where the `...` denote potential further arguments to `f`. That is, the first argument of the function can be moved from the argument list to in front of the function, before the pipe symbol. The `tidyverse` functions take the data as their first argument, which means that the use of pipes allow us to very conveniently chain together multiple steps of data analysis. In our case, we can rewrite the original

```{r}
#| eval: false
select(
  filter(
    mutate(dat, SelfingMechanism = ifelse(Status < 2, "simple", "complex")),
    SelfingMechanism == "complex"
  ),
  Species
)
```

with the use of pipes, in a much more transparent way:

```{r}
#| eval: false
dat %>%
  mutate(SelfingMechanism = ifelse(Status < 2, "simple", "complex")) %>%
  filter(SelfingMechanism == "complex") %>%
  select(Species)
```

Again, the pipe `%>%` should be pronounced *then*. We take the data, *then* we mutate it, *then* we filter for complex selfing, and *then* we select one of the columns. In performing these steps, each function both receives and returns data. Thus, by starting out with the original `dat`, we no longer need to write out the data argument of the functions explicitly. Instead, the pipe takes care of that automatically for us, making the functions receive as their first input argument the piped-in data, and in turn producing transformed data as their output---which becomes the input for the next function in line.

In fact, there is technically no need to even assign `dat`. The pipe can just as well start with the `read_csv` call to import the dataset:

```{r}
#| message: false
read_csv("Goldberg2010_data.csv") %>%
  mutate(SelfingMechanism = ifelse(Status < 2, "simple", "complex")) %>%
  filter(SelfingMechanism == "complex") %>%
  select(Species)
```


## Exercises

1. The `Smith2003_data.txt` dataset we worked with last time occasionally has the entry `-999` in its last three columns. This stands for unavailable data. In R, there is a built-in way of referring to such information: by setting a variable to `NA`. (So, for example, `x <- NA` will set the variable `x` to `NA`.) Modify these columns (using `mutate`) so that the entries which are equal to `-999` are replaced with `NA`.
2. Remove all rows from the data which contain one or more `NA` values (hint: look up the function `drop_na`). How many rows are retained? And what was the original number of rows?

The `iris` dataset is a built-in table in R. It contains measurements of petal and sepal characteristics from three flower species belonging to the genus *Iris* ([*I. setosa*](https://en.wikipedia.org/wiki/Iris_setosa), [*I. versicolor*](https://en.wikipedia.org/wiki/Iris_versicolor), and [*I. virginica*](https://en.wikipedia.org/wiki/Iris_virginica)). If you type `iris` in the console, you will see the dataset displayed. In solving the problems below, feel free to use the all-important [`dplyr` cheat sheet](https://btep.ccr.cancer.gov/docs/rintro/resources/dplyr_cheatsheet.pdf).

3. The format of the data is not a `tibble`, but a `data.frame`. As mentioned in the previous chapter, the two are basically the same for practical purposes, though internally, `tibble`s do offer some advantages. Convert the `iris` data frame into a tibble. (Hint: look up the `as_tibble` function.)
4. Select the columns containing petal and sepal length, and species identity.
5. Get those rows of the data with petal length less than 4 cm, but sepal length greater than 4 cm.
6. Sort the data by increasing petal length but decreasing sepal length.
7. Create a new column called `MeanLength`. It should contain the average of the petal and sepal length (i.e., petal length plus sepal length, divided by 2) of each individual flower.
8. Perform the operations from the previous two exercises in a single long function call (using function composition).
